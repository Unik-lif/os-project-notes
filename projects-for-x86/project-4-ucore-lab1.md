---
description: 记录uCore的笔记
---

# Project 4: ucore lab1

## 前置知识：

### 处理器硬件：

#### intel 80386：

该硬件拥有四种运行模式，分别为：实模式、保护模式、SMM模式和虚拟8086模式。

在80386机器启动时，其一开始会运行在实模式之中，此时能访问的空间为20-bit，即1MB。在处理了基本的操作后，机器将会进入保护模式。保护模式需要在实模式完成控制寄存器初始化和页表初始化后，通过设置CR0寄存器才能进入。

保护模式拥有很多强大的功能，如虚存与页表机制，以及优先级机制。其还包含0\~3四个特权级别，而OS往往运行在最高的特权级0上。

为了满足兼容性需求，Intel 80386允许虚存的页机制和段机制共存，因此在该机器中往往存在三个地址：物理地址，线性地址和逻辑地址。

下面展示地址的对应关系：

```
仅启动分段机制：
           ___________
逻辑地址 -> |   段机制  | -> 线性地址=物理地址

同时启动分段机制和分页机制：
           ___________                ___________
逻辑地址 -> |   段机制  | -> 线性地址 -> |   页机制  | -> 物理地址
```

### 第三讲课堂笔记：

#### BIOS启动后发生了什么：

* 将加载程序加载磁盘引导扇区到0x7c00
* **加载程序：**将操作系统代码的代码和数据从硬盘加到内存中
* 跳转到操作系统的起始位置

**为什么不让BIOS直接读取操作系统镜像到内存中去？**

因为磁盘的文件系统是可能不一样的，BIOS不太可能认得了全部磁盘内的文件系统格式。但如果是同一个磁盘对应的加载程序来干这事就能解决了，因为他们都是原装配套的。

**BIOS启动流程：**

加电后BIOS自0xffff0启动 -> BIOS内硬件POST自检 -> 为读入多分区利用主引导记录MBR格式（检查分区表正确性）-> 跳转到活动分区

**加载程序：**

加载可选系统内核参数 -> 依据配置文件跳转到内核执行

在BIOS启动时存在着大量的脏活和统一约定规范，因此其实这里的细节很难顶。

#### 中断与系统调用：

**系统调用：**应用程序主动向内核发送服务请求。-> 异步或者同步

**异常：**非法指令或者其他原因导致当前指令执行失败后的处理请求。-> **当前指令需要处理完，所以同步**

**中断：**来自硬件设备的处理请求。-> 异步，因为**硬件不知道上层**的结构。

<figure><img src="../.gitbook/assets/Screenshot 2023-03-18 101431.png" alt=""><figcaption><p>这个图画的很不错</p></figcaption></figure>

**中断的处理流程：**

* **硬件：**在CPU初始化时，设置中断使能标志。
  * 根据内部或者外部事件设置中断标志
  * 根据中断向量调用相应中断服务例程
* 软件：保存现场 -> 处理中断服务 -> 清除中断标记 -> 恢复现场

系统调用：与函数调用相比

* INT和IRET -> 系统调用，涉及堆栈切换和特权级的转换
* CALL和RET -> 常规调用，常规调用时没有堆栈切换

### 第四讲课堂笔记略过：

陈渝老师的课讲的不错，不过作为学生，课下还是多看一下相关的参考资料。在uCore的文档之中也有较为详尽的资料可供参考，相对于6.828来说学习体验似乎顺滑了不少。

#### 控制寄存器CR0

进入保护模式需要操作控制寄存器CR0，我们简单过一下这边的知识点。

首先，控制寄存器仅在取得Ring 0权限下才可以进行读取和写入的操作，且这些寄存器有部分特殊的位是始终需要维持0以提供一些简单的安全检查。

更进一步，CR0寄存器是控制寄存器中控制操作系统模式和处理器状态的寄存器，在Boot阶段发挥着模式切换的功效，因此它的内部结构需要做简单的研究和探讨。

<figure><img src="../.gitbook/assets/Screenshot 2023-03-18 153735.png" alt=""><figcaption><p>CR0 register structure</p></figcaption></figure>

其中的一些位分别能实现页表机制，缓存机制等等功能，在BOOT阶段用到的其实只有CR0.PE这个位置。在PE位被设置为1的时候，系统将会启动保护模式。反之，系统将会启动实模式。

### RTFM Intel 80386.

指导书推荐看一下部分章节，于是简要在此做一些摘记。

#### 第四章：系统结构

在386机器中存在五类寄存器：

* EFLAGS
  * IF：中断标志，该标志的设置能让CPU辨认出外部的中断请求
  * NT：嵌套任务标志，该标志影响`IRET`指令的工作
  * RF：恢复标志，可以用于关闭debug产生的异常
  * TF：内陷标志，开启该功能后CPU能在每执行一条指令的同时产生异常，用以更方便去进行调试
  * VM：虚拟8086机模式，可以用于让机器运行在虚拟的8086模式之中

<figure><img src="../.gitbook/assets/Screenshot 2023-03-18 190805.png" alt=""><figcaption><p>EFLAGS Register</p></figcaption></figure>

* 内存管理寄存器：该类别中存在四类寄存器
  * GDTR：全局描述符表寄存器，指向段描述符表格GDT
  * LDTR：局部描述符表寄存器，指向局部描述符表格LDT
  * IDTR：中断描述符表寄存器，指向中断处理这IDT
  * TR：任务寄存器，指向当前处理器完成任务所需要的信息
*   控制寄存器：控制寄存器仅能通过general Registers，即一般寄存器进行赋值。

    * 控制寄存器即CR0，CR1，CR2，CR3
    * CR0寄存器：系统控制flags存储者
      * EM：Emulation，用于指示协处理器是否被模拟出来了
      * ET：扩展类型，同样与协处理器相关
      * MP：Math Present，控制Wait指令，同样与协处理器相关
      * PE：Protection Enable，是否开了保护模式
      * PG：是否采用页表方式进行地址映射
      * TS：与协处理器相关，现代用语为进程切换
    * CR2寄存器：在页表被设置时，用于处理页错误
    * CR3寄存器：在页表被设置时用于找到当前进程的Page Table Directory位置

    <figure><img src="../.gitbook/assets/Screenshot 2023-03-18 193006.png" alt=""><figcaption><p>Control Registers</p></figcaption></figure>


* 调试寄存器：用于提供在不修改代码段的情况下实现指令级别的断点设置
* 测试寄存器：用于检查TLB表的可信性，作它们的测试所用



